import h5py
import numpy as np
import os
import matplotlib.pyplot as plt
from src.h2s_io import kaiser_factor

def plot_correlation_function(
    filename,
    output_png=None,
    loglog=True,
    show=True,
    r_index=0,
    xi_index=1,
    err_index=2 
):
    """
    Plots xi(r) vs r (and optionally error bars) from a .txt file.
    Now supports plotting error bars if present (Corrfunc output).

    Parameters:
    -----------
    filename : str
        Path to the .txt file (output from Corrfunc or CUTE).
    output_png : str or None
        If provided, path to save the plot as a PNG file.
    loglog : bool
        If True, use log-log scale.
    show : bool
        If True, display the plot interactively.
    r_index : int
        Index of the r column.
    xi_index : int
        Index of the xi(r) column.
    err_index : int
        Index of the error column (if present).
    """
    # Load the data
    data = np.loadtxt(filename, comments='#', delimiter=',')
    r = data[:, r_index]
    xi = data[:, xi_index]
    # If there is a third column, treat as error bars
    has_error = data.shape[1] > err_index

    plt.figure(figsize=(6, 5))
    if loglog:
        plt.xscale('log')
        plt.yscale('log')

    if has_error:
        err = data[:, err_index]
        plt.errorbar(r, xi, yerr=err, fmt='+', capsize=2, label=r'$\xi(r)$ with errors')
    else:
        plt.plot(r, xi, marker='+', linestyle='-', label=r'$\xi(r)$')

    plt.xlabel(r"$r$ [$h^{-1}$ Mpc]")
    plt.ylabel(r"$\xi(r)$")
    plt.title("Galaxy 2-Point Correlation Function")
    plt.grid(True, which='both', ls='--', alpha=0.3)
    plt.legend()

    if output_png:
        plt.tight_layout()
        plt.savefig(output_png, dpi=300)
        print(f" Plot saved to: {output_png}")

    if show:
        plt.show()

    plt.close()

def plot_radial_profile(profile_file, output_png=None, show=True, loglog = True):
    """
    Plot the radial profile of satellites (counts) from an HDF5 file
    without any analytic fitting, using log-log axes.

    Parameters:
    -----------
    profile_file : str
        Path to the HDF5 file generated by compute_radial_profile, containing:
            - Dataset "radial_bins": array of bin centers (r values).
            - Dataset "counts": array of galaxy counts per radial bin.
    output_png : str or None
        If provided, the path where the figure will be saved as a PNG file.
    show : bool
        If True, display the plot interactively.
    """
    if not os.path.isfile(profile_file):
        raise FileNotFoundError(f"Profile file not found: {profile_file}")

    # Load radial profile data
    with h5py.File(profile_file, "r") as f:
        r = f["radial_bins"][:]
        counts = f["counts"][:]

    # Create log-log plot of observed radial counts
    plt.figure(figsize=(6, 5))
    plt.plot(r, counts, marker = '.', color='steelblue', linewidth=1.5, label="Satellite counts")
    if loglog:
        plt.xscale('log')
        plt.yscale('log')

    plt.xlabel(r"$r$ [$h^{-1}$ Mpc]")
    plt.ylabel("Satellite counts")
    plt.title("Radial Profile (Satellite Counts)")
    plt.grid(True, ls='--', alpha=0.3)
    plt.legend()

    if output_png:
        plt.tight_layout()
        plt.savefig(output_png, dpi=300)
        print(f"Plot saved to: {output_png}")

    if show:
        plt.show()

    plt.close()


def plot_radial_profile_fit(profile_file, params, output_png=None, show=True, loglog=True):
    """
    Plot the radial profile of satellites (density) from an HDF5 file
    and overlay the fitted analytic function, using log-log axes.

    The analytic form is:
        N_density(r) = N0 * (r/r0)^alpha * (1 + (r/r0)^beta)^kappa

    Parameters:
    -----------
    profile_file : str
        Path to the HDF5 file created by compute_radial_profile, containing:
            - Dataset "radial_bins": array of bin centers (r values)
            - Dataset "counts": array of raw counts per bin
    params : sequence of 5 floats
        Fitted parameters [alpha, beta, r0, N0, kappa].
    output_png : str or None
        If provided, path where the figure will be saved as a PNG.
    show : bool
        If True, display the figure interactively.
    """
    if not os.path.isfile(profile_file):
        raise FileNotFoundError(f"Profile file not found: {profile_file}")

    # Load radial profile data
    with h5py.File(profile_file, "r") as f:
        r = f["radial_bins"][:]
        counts = f["counts"][:]
    alpha, beta, r0, N0, kappa = params

    # Analytic density function
    def analytic_density(r_vals):
        return N0 * (r_vals / r0)**alpha * (1.0 + (r_vals / r0)**beta)**kappa

    N_analytic = analytic_density(r)

    # Plot observed density and analytic fit on log-log axes
    plt.figure(figsize=(5, 5))
    if loglog:
        plt.xscale('log')
        plt.yscale('log')

    plt.plot(r, counts, 'o', label="Observed density", markersize=4)
    plt.plot(r, N_analytic, '-', label="Analytic fit")

    plt.xlabel(r"$r$ [$h^{-1}$ Mpc]")
    #plt.ylabel("N_density(r) [counts / Î”r]")
    plt.ylabel("N_counts")
    plt.title("Radial Profile (density) with Analytic Fit (log-log)")
    plt.grid(True, ls='--', alpha=0.3)
    plt.legend()

    if output_png:
        plt.tight_layout()
        plt.savefig(output_png, dpi=300)
        print(f"Plot saved to: {output_png}")

    if show:
        plt.show()

    plt.close()

# src/h2s_plots.py

import numpy as np
import os
import matplotlib.pyplot as plt
import h5py

def plot_vr_distribution(vr_profile_file, output_png=None, loglog=False, show=True):
    """
    Plot the radial.velocity distribution (density) of satellites from an HDF5 file.

    This function expects an HDF5 file created by compute_vr_profile, containing:
      - Dataset "velocity_bins": array of bin centers for v_r
      - Dataset "density": density in each bin (counts / bin_width)

    Parameters:
    -----------
    vr_profile_file : str
        Path to the HDF5 file with radial-velocity profile.
    output_png : str or None
        If provided, path where the figure will be saved as a PNG.
    loglog : bool
        If True, use log-log scaling on both axes.
    show : bool
        If True, display the figure interactively.
    """
    if not os.path.isfile(vr_profile_file):
        raise FileNotFoundError(f"File not found: {vr_profile_file}")

    with h5py.File(vr_profile_file, "r") as f:
        v_bins = f["velocity_bins"][:]   # bin centers for v_r
        density = f["density"][:]        # counts/bin_width in each bin

    plt.figure(figsize=(6, 5))
    if loglog:
        plt.xscale('log')
        plt.yscale('log')

    plt.plot(v_bins, density, marker='.', label=r'$dN/dv_r$')
    plt.xlabel(r"$v_r$ [$\mathrm{km/s}$]")
    plt.ylabel(r"Density [counts / l_Bin")
    plt.title("Radial Velocity Distribution")
    plt.grid(True, which='both', ls='--', alpha=0.3)
    plt.legend()

    if output_png:
        plt.tight_layout()
        plt.savefig(output_png, dpi=300)
        print(f"Plot saved to: {output_png}")

    if show:
        plt.show()

    plt.close()


def plot_vtan_distribution(vtan_profile_file, output_png=None, loglog=False, show=True):
    """
    Plot the tangential velocity distribution (density) of satellites from an HDF5 file.

    This function expects an HDF5 file created by compute_vtheta_profile, containing:
      - Dataset "velocity_bins": array of bin centers for |v_theta|
      - Dataset "density": density in each bin (counts / bin_width)

    Parameters:
    -----------
    vtheta_profile_file : str
        Path to the HDF5 file with |v_theta| profile.
    output_png : str or None
        If provided, path where the figure will be saved as a PNG.
    loglog : bool
        If True, use log-log scaling on both axes.
    show : bool
        If True, display the figure interactively.
    """
    if not os.path.isfile(vtan_profile_file):
        raise FileNotFoundError(f"File not found: {vtan_profile_file}")

    with h5py.File(vtan_profile_file, "r") as f:
        v_bins = f["velocity_bins"][:]   # bin centers for |v_theta|
        density = f["density"][:]        # counts/bin_width in each bin

    plt.figure(figsize=(6, 5))
    if loglog:
        plt.xscale('log')
        plt.yscale('log')

    plt.plot(v_bins, density, marker='.', label=r'$dN/d|v_\theta|$')
    plt.xlabel(r"$|v_\theta|$ [$\mathrm{km/s}$]")
    plt.ylabel(r"Density [counts / l_Bin")
    plt.title("Tangential Velocity Distribution")
    plt.grid(True, which='both', ls='--', alpha=0.3)
    plt.legend()

    if output_png:
        plt.tight_layout()
        plt.savefig(output_png, dpi=300)
        print(f"Plot saved to: {output_png}")

    if show:
        plt.show()

    plt.close()

def plot_kaiser_comparison(
    real_file,
    redshift_file,
    omega_m,
    b,
    gamma=0.55,
    output_png=None,
    xlim=None,
    ylim=None,
    loglog=True,
    show=True
):
    """
    Plots the real-space and redshift-space correlation functions, and the Kaiser prediction
    using the generalized growth rate exponent gamma.

    Parameters
    ----------
    real_file : str
        Path to .txt file with columns: r, xi_real.
    redshift_file : str
        Path to .txt file with columns: r, xi_redshift.
    omega_m : float
        Value of Omega_m at the relevant redshift.
    b : float
        Linear bias of the sample.
    gamma : float
        Growth rate exponent (default: 0.55 for LCDM).
    output_png : str or None
        If set, saves the plot to this file.
    show : bool
        If True, displays the plot interactively.
    """
    def kaiser_factor(omega_m, b, gamma):
        growth_rate = omega_m ** gamma
        ratio = growth_rate / b
        f = 1 + (2/3) * ratio + (1/5) * ratio**2
        return f

    # Load data
    r_real, xi_real, err_real = np.loadtxt(real_file, unpack=True, delimiter=",")
    r_red, xi_red, err_red = np.loadtxt(redshift_file, unpack=True, delimiter=",")

    # Compute Kaiser factor
    fkaiser = kaiser_factor(omega_m, b, gamma)
    xi_kaiser = fkaiser * xi_real

    plt.figure(figsize=(7,5))
    plt.plot(r_real, xi_real, 'b-', label=r'Real-space $\xi(r)$')
    plt.plot(r_red, xi_red, 'g--', label=r'Redshift-space $\xi(s)$')
    plt.plot(r_real, xi_kaiser, 'r-.',
             label=fr'Kaiser: $f_\mathrm{{K}}\,\xi(r)$, $\gamma$={gamma:.2f}')
    if loglog:
        plt.xscale('log')
        plt.yscale('log')
    plt.xlabel(r'$r$ [$h^{-1}$ Mpc]')
    if xlim is not None:
        plt.xlim(xlim)
    if ylim is not None:
        plt.ylim(ylim)
    plt.ylabel(r'$\xi(r)$')
    plt.title(fr'Correlation Function: Real, Redshift, Kaiser ($\gamma$={gamma:.2f})')
    plt.legend()
    plt.grid(True, which='both', ls='--', alpha=0.3)
    if output_png:
        plt.tight_layout()
        plt.savefig(output_png, dpi=300)
        print(f"Plot saved to: {output_png}")
    if show:
        plt.show()
    plt.close()

def plot_hmf(
    h5file,
    output_path="HMF.png",
    box_size=1000.0,
    logM_min=10.5,
    logM_max=14.5,
    n_bins=70,
    show=True
):
    """
    Plot the halo mass function (HMF) for dark matter halos, centrals, and satellites
    from a single flux cut.

    Parameters:
        h5file (str): Path to the .h5 results file.
        label (str): Legend label for the centrals/satellites curves.
        color (str): Color for the centrals/satellites curves.
        output_path (str): Output file path for the plot image.
        box_size (float): Size of the simulation box (Mpc/h).
        logM_min (float): Minimum log10 halo mass to display.
        logM_max (float): Maximum log10 halo mass to display.
        n_bins (int): Number of bins to display (data is NOT rebinned, only filtered).
        show (bool): If True, display the plot interactively.
    """
    volume = box_size**3

    with h5py.File(h5file, "r") as f:
        dset = f["data/bins"]
        logM_bin_mins = dset["M_min_bin"][:]
        logM_bin_maxs = dset["M_max_bin"][:]
        logM_centers = 0.5 * (logM_bin_mins + logM_bin_maxs)
        M_centers = 10**logM_centers

        # Mask for the selected log mass range
        mask = (logM_centers >= logM_min) & (logM_centers <= logM_max)
        logM_centers = logM_centers[mask]
        M_centers = M_centers[mask]

        # Optionally select only n_bins evenly spaced bins (for display only)
        if n_bins < len(M_centers):
            idx = np.linspace(0, len(M_centers) - 1, n_bins, dtype=int)
            logM_centers = logM_centers[idx]
            M_centers = M_centers[idx]
            mask_idx = np.where(mask)[0][idx]
        else:
            mask_idx = np.where(mask)[0]

        # Calculate real bin width for normalization
        if len(logM_bin_mins[mask_idx]) > 1:
            bin_width = logM_bin_maxs[mask_idx][0] - logM_bin_mins[mask_idx][0]
        else:
            bin_width = 0.1  # fallback value

        N_H = dset["N_Halos"][:][mask_idx] / (volume * bin_width)
        N_C = dset["N_C"][:][mask_idx] / (volume * bin_width)
        N_S = dset["N_S"][:][mask_idx] / (volume * bin_width)

    plt.figure(figsize=(7, 5))
    plt.plot(M_centers, N_C, ls='-', lw=1.5, color='orange', label=f"Centrals")
    plt.plot(M_centers, N_S, ls='--', lw=1.5, color='steelblue', label=f"Satellites")
    plt.plot(M_centers, N_H, ls='-', lw=1.5, color='k', label="DM Halos")

    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel(r"$M_{\rm halo}\ [h^{-1} M_\odot]$")
    plt.ylabel(r"$dn/d\log_{10}(M)\ [({\rm Mpc}/h)^{-3}]$")
    plt.title("Mass function")
    plt.grid(True, ls='--', alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_path, dpi=300)
    print(f"Results stored in: {output_path}")
    if show:
        plt.show()
    plt.close()

def plot_hod(
    h5file,
    output_path="HOD_occupation.png",
    show=True
):
    """
    Plot the Halo Occupation Distribution (HOD) for centrals and satellites for a given flux cut.

    Parameters:
        h5file (str): Path to the HDF5 input file with HOD data.
        label (str): Label for the flux cut (shown in legend).
        color (str): Color used for plotting.
        output_path (str): Path to save the output plot.
        show (bool): If True, display the plot interactively.
    """

    with h5py.File(h5file, "r") as f:
        dset = f["data/bins"]
        logM = 0.5 * (dset["M_min_bin"][:] + dset["M_max_bin"][:])
        M = 10 ** logM
        N_H = dset["N_Halos"][:]
        N_C = dset["N_C"][:]
        N_S = dset["N_S"][:]

        with np.errstate(divide='ignore', invalid='ignore'):
            occ_C = np.where(N_H > 0, N_C / N_H, 0)
            occ_S = np.where(N_H > 0, N_S / N_H, 0)

    plt.figure(figsize=(7, 5))
    plt.plot(M, occ_C, ls='-', lw=1.5, label=f"Centrals")
    plt.plot(M, occ_S, ls='--', lw=1.5, label=f"Satellites")

    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel(r"$M_{\rm halo}\ [h^{-1} M_\odot]$")
    plt.ylabel(r"$\langle N(M) \rangle$")
    plt.title("Halo Occupation Distribution (HOD)")
    plt.grid(True, ls='--', alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_path, dpi=300)
    print(f"Plot saved to: {output_path}")
    
    if show:
        plt.show()
    plt.close()

def plot_2pcf_ratio(file_normal, file_shuffled, output_png=None, 
                    xlim=(0.01, 100.0), ylim=(0.5, 1.4), show=True):
    """
    Plot the ratio between two real-space two-point correlation functions (2PCF):
    a normal catalog and a shuffled catalog.

    Parameters:
    -----------
    file_normal : str
        Path to the file containing the normal 2PCF (columns: r, xi, err).
    file_shuffled : str
        Path to the file containing the shuffled 2PCF (columns: r, xi, err).
    output_png : str or None
        Path to save the output figure as a PNG file. If None, the figure is not saved.
    xlim : tuple
        Limits for the x-axis in the plot (default: (0.01, 100)).
    ylim : tuple
        Limits for the y-axis in the plot (default: (0.5, 1.4)).
    show : bool
        If True, display the plot interactively.
    """
    # Load data
    r_normal, xi_normal, _ = np.loadtxt(file_normal, unpack=True, delimiter=',')
    r_shuffled, xi_shuffled, _ = np.loadtxt(file_shuffled, unpack=True, delimiter=',')

    # Compute ratio and avoid division by zero
    ratio = np.ones_like(xi_normal)
    mask = xi_shuffled != 0
    ratio[mask] = xi_normal[mask] / xi_shuffled[mask]
    ratio[~mask] = np.nan  # Assign NaN where division by zero occurs

    # Plot the ratio
    plt.figure(figsize=(9, 6))
    plt.plot(r_normal, ratio, 'k-', lw=1.5)

    plt.xlabel(r'$r$ [Mpc/h]')
    plt.ylabel(r'$\xi_\mathrm{normal} / \xi_\mathrm{shuffled}$')
    plt.xscale('log')
    plt.xlim(*xlim)
    plt.ylim(*ylim)
    plt.grid(True, which="both", ls="--", alpha=0.5)
    plt.title("Ratio of Normal to Shuffled 2PCF")

    if output_png:
        plt.tight_layout()
        plt.savefig(output_png, dpi=200)
        print(f"Plot saved to: {output_png}")

    if show:
        plt.show()
        
    plt.close()

def plot_kaiser_ratio(real_file, redshift_file, omega_m, bias, gamma,
                      output_png=None, xlim=(1, 100), ylim=(0.75, 1.5), show=True):
    """
    Plot the ratio of redshift-space to real-space two-point correlation functions (2PCF),
    and overlay the theoretical Kaiser factor.

    Parameters:
    -----------
    real_file : str
        Path to the real-space 2PCF file (columns: r, xi, err).
    redshift_file : str
        Path to the redshift-space 2PCF file (columns: r, xi, err).
    omega_m : float
        Matter density parameter Î©_m.
    bias : float
        Galaxy bias parameter.
    gamma : float
        Growth rate exponent (default ~0.55 for LCDM).
    output_png : str or None
        Path to save the plot as a PNG file. If None, the figure isn't saved.
    xlim : tuple
        Limits for x-axis (default: (1, 100) Mpc/h).
    ylim : tuple
        Limits for y-axis (default: (0.75, 1.5)).
    show : bool
        If True, display the plot interactively.
    """

    # Load data
    data_real = np.loadtxt(real_file, comments='#', delimiter=',')
    data_redshift = np.loadtxt(redshift_file, comments='#', delimiter=',')

    r_real = data_real[:, 0]
    xi_real = data_real[:, 1]

    r_redshift = data_redshift[:, 0]
    xi_redshift = data_redshift[:, 1]

    assert np.allclose(r_real, r_redshift) 

    # Calculate Kaiser factor
    f_kaiser = kaiser_factor(omega_m, bias, gamma)
    print(f"Kaiser factor: {f_kaiser:.4f}")

    # Compute ratios
    mask = xi_real > 1e-8
    ratio_redshift = xi_redshift[mask] / xi_real[mask]
    ratio_kaiser = np.full_like(r_real[mask], f_kaiser)

    # Plotting
    plt.figure(figsize=(8, 5))
    plt.plot(r_real[mask], ratio_redshift, 'g--', label=r'$\xi(s)/\xi(r)$')
    plt.plot(r_real[mask], ratio_kaiser, 'r-.', label=fr'Kaiser factor $f_k = {f_kaiser:.3f}$')
    plt.axhline(1, color='k', linestyle=':', alpha=0.5, label='Ratio = 1')

    plt.xscale('log')
    plt.xlim(*xlim)
    plt.ylim(*ylim)
    plt.xlabel(r'$r\ [h^{-1}\ \mathrm{Mpc}]$', fontsize=13)
    plt.ylabel('Ratio', fontsize=13)
    plt.title('Ratio of Redshift and Kaiser to Real-space Correlation')
    plt.grid(True, ls='--', alpha=0.4)
    plt.legend()
    plt.tight_layout()

    if output_png:
        plt.savefig(output_png, dpi=300)
        print(f"Plot saved to: {output_png}")

    if show:
        plt.show()

    plt.close()

def plot_hmf_comparison(halo_bins_file, conformity_file, output_png=None,
                        boxsize=1000, bins=np.linspace(10.5,14.5,71), loglog=True, show=True):
    """
    Plot a comparison of Halo Mass Functions (HMF) from two different HDF5 files:
    - Halo bins file: containing halo counts for each bin.
    - Conformity file: containing halo counts from conformity analysis.

    Parameters:
    -----------
    halo_bins_file : str
        Path to the halo bins HDF5 file.
    conformity_file : str
        Path to the conformity HDF5 file.
    output_png : str or None
        Path to save the output figure. If None, the figure won't be saved.
    volume : float
        Volume of the simulation box (default is 1000^3 Mpc^3/h^3).
    bin_width : float
        Logarithmic bin width for normalization.
    show : bool
        If True, display the figure interactively.
    """
    volume = boxsize**3  # Volume of the simulation box
    bin_width = bins[1] - bins[0]  # Logarithmic bin width

    # Read parent halos from the new HDF5 file
    with h5py.File(halo_bins_file, "r") as f:
        halo_counts_bins = []

        for i in range(70):
            group_name = f"bin_{i:02d}"
            mass = f[group_name]['Mass_shuffled'][:]   
            parent_mask = mass > 0
            halos_in_bin = np.sum(parent_mask)
            halo_counts_bins.append(halos_in_bin / (volume * bin_width))

        bin_centers = 0.5 * (bins[:-1] + bins[1:])

    # Read halos from the conformity HDF5 file
    with h5py.File(conformity_file, "r") as fc:
        N_halos_conformity = fc["data/bins/N_Halos"][:] / (volume * bin_width)
        M_min_bin_conformity = fc["data/bins/M_min_bin"][:]
        M_max_bin_conformity = fc["data/bins/M_max_bin"][:]

        bin_centers_conformity = 0.5 * (M_min_bin_conformity + M_max_bin_conformity)

    # Plot
    plt.figure(figsize=(10, 6))

    bin_centers_linear = 10 ** bin_centers
    bin_centers_conformity_linear = 10 ** bin_centers_conformity

    plt.plot(bin_centers_linear, halo_counts_bins, ls='-', label='Shuffled Halo Catalog', color='k')
    plt.plot(bin_centers_conformity_linear, N_halos_conformity, ls='--', label='Original Halo Catalog', color='darkorange')

    if loglog:
        plt.xscale('log')
        plt.yscale('log')
    plt.xlabel(r'$M_{\mathrm{halo}}\,[M_\odot/h]$', fontsize=14)
    plt.ylabel(r'Number density [$h^3\,\mathrm{Mpc}^{-3}\,\mathrm{dex}^{-1}$]', fontsize=14)
    plt.title('Halo Mass Function Comparison', fontsize=16)
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.legend()
    plt.tight_layout()

    plt.savefig(output_png, dpi=300)

    # Show the figure
    plt.show()